<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D 地球儀 - 震撼音效版</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Segoe UI', sans-serif; }
        
        /* 標籤樣式 */
        .label {
            position: absolute;
            color: #ffffff;
            background: rgba(0, 15, 30, 0.7);
            padding: 4px 8px;
            border-radius: 2px;
            font-size: 11px; 
            border-bottom: 1px solid #4db8ff;
            pointer-events: none;
            transform: translate(-50%, -20px);
            opacity: 0;
            transition: opacity 0.3s;
            white-space: nowrap;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            z-index: 10;
        }
        .label.visible { opacity: 1; }
        .label strong { display: block; font-size: 1.1em; color: #4db8ff; margin-bottom: 2px; font-weight: 600; }
        .label::after {
            content: ''; position: absolute; bottom: -15px; left: 50%;
            width: 1px; height: 15px; background: linear-gradient(to bottom, #4db8ff, transparent);
        }

        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #4db8ff; font-family: 'Courier New', Courier, monospace;
            background: rgba(0,20,40,0.9); padding: 10px 20px; border-radius: 4px;
            pointer-events: none; z-index: 20; border: 1px solid #4db8ff;
            text-transform: uppercase; font-size: 12px; text-shadow: 0 0 5px #4db8ff;
        }

        /* --- 極簡 UI 容器 --- */
        #ui-container {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 30;
            width: max-content;
        }

        .control-btn {
            background: rgba(10, 15, 20, 0.8);
            border: 1px solid #555;
            color: #aaa;
            padding: 12px 30px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            backdrop-filter: blur(5px);
        }

        #peace-btn.active, #peace-btn:hover {
            border-color: #00ffaa;
            color: #00ffaa;
            box-shadow: 0 0 15px rgba(0, 255, 170, 0.4);
            background: rgba(0, 40, 20, 0.8);
        }

        #fire-btn.active, #fire-btn:hover {
            border-color: #ff3333;
            color: #ff3333;
            box-shadow: 0 0 20px rgba(255, 51, 51, 0.6);
            background: rgba(60, 0, 0, 0.8);
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    
    <div id="labels-container"></div>
    <div id="loading">SYSTEM READY... CLICK BUTTONS TO ACTIVATE AUDIO</div>
    
    <div id="ui-container">
        <button id="peace-btn" class="control-btn active">PEACE</button>
        <button id="fire-btn" class="control-btn">FIRE</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        const CONFIG = { earthRadius: 5 };

        let scene, camera, renderer, controls;
        let earthGroup, earthMesh, cloudMesh, ufoGroup, auroraGroup;
        const markers = [];
        const activeMissiles = [];
        const activeExplosions = [];
        const activeMushrooms = [];
        
        const clock = new THREE.Clock();
        const textureLoader = new THREE.TextureLoader();
        let isWarActive = false;
        let warInterval = null;

        // --- 音效系統 (Web Audio API) ---
        let audioCtx;
        
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playExplosionSound(isSuper) {
            if (!audioCtx) return;

            const t = audioCtx.currentTime;
            
            // 1. 噪音源 (白噪音)
            const bufferSize = audioCtx.sampleRate * 2.0; // 2秒
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;

            // 2. 濾波器 (模擬爆炸的低頻)
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 1000;
            filter.frequency.exponentialRampToValueAtTime(10, t + (isSuper ? 2.5 : 1.0)); // 頻率隨時間下降

            // 3. 音量控制 (Envelope)
            const gain = audioCtx.createGain();
            const volume = isSuper ? 0.8 : 0.1; // 超級核彈大聲很多
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(volume, t + 0.05); // 快速起音
            gain.gain.exponentialRampToValueAtTime(0.01, t + (isSuper ? 2.0 : 0.8)); // 衰減

            // 連接：噪音 -> 濾波 -> 音量 -> 輸出
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            noise.start(t);
            noise.stop(t + (isSuper ? 3.0 : 1.0));
        }

        // --- 地標資料 ---
        const landmarksData = [
            { name: "台灣 (台北101)", lat: 25.0330, lon: 121.5654, type: 'needle' },
            { name: "北京紫禁城", lat: 39.9163, lon: 116.3971, type: 'temple', region: 'ChinaTarget' },
            { name: "萬里長城", lat: 40.4319, lon: 116.5704, type: 'wall', region: 'ChinaTarget' }, 
            { name: "上海東方明珠", lat: 31.2397, lon: 121.4998, type: 'needle', region: 'ChinaTarget' },
            { name: "廣州塔", lat: 23.1067, lon: 113.3246, type: 'tower', region: 'ChinaTarget' },
            { name: "深圳平安中心", lat: 22.5333, lon: 114.0544, type: 'needle', region: 'ChinaTarget' },
            { name: "成都", lat: 30.5728, lon: 104.0668, type: 'dome', region: 'ChinaTarget' },

            { name: "日本富士山", lat: 35.3606, lon: 138.7274, type: 'mountain' },
            { name: "東京鐵塔", lat: 35.6586, lon: 139.7454, type: 'tower' },
            { name: "印度泰姬瑪哈陵", lat: 27.1751, lon: 78.0421, type: 'taj' },
            { name: "柬埔寨吳哥窟", lat: 13.4125, lon: 103.8670, type: 'temple' },
            { name: "杜拜哈里發塔", lat: 25.1972, lon: 55.2744, type: 'needle' },
            { name: "新加坡金沙酒店", lat: 1.2834, lon: 103.8607, type: 'sails' },

            { name: "羅馬競技場", lat: 41.8902, lon: 12.4922, type: 'colosseum' },
            { name: "英國巨石陣", lat: 51.1789, lon: -1.8262, type: 'stonehenge' },
            { name: "巴黎艾菲爾鐵塔", lat: 48.8584, lon: 2.2945, type: 'tower' },
            { name: "雅典衛城", lat: 37.9715, lon: 23.7257, type: 'temple' }, 
            { name: "莫斯科克里姆林宮", lat: 55.7520, lon: 37.6173, type: 'dome' },

            { name: "埃及金字塔", lat: 29.9792, lon: 31.1342, type: 'pyramid' },
            { name: "吉力馬札羅山", lat: -3.0674, lon: 37.3556, type: 'mountain' },
            { name: "紐約自由女神像", lat: 40.6892, lon: -74.0445, type: 'statue' },
            { name: "舊金山金門大橋", lat: 37.8199, lon: -122.4783, type: 'wall' },
            { name: "秘魯馬丘比丘", lat: -13.1631, lon: -72.5450, type: 'ruins' },
            { name: "巴西救世基督像", lat: -22.9519, lon: -43.2105, type: 'cross' },
            { name: "雪梨歌劇院", lat: -33.8568, lon: 151.2153, type: 'sails' },
            { name: "亞特蘭提斯", lat: 35.0, lon: -40.0, type: 'atlantis' }
        ];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 16);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);

            earthGroup = new THREE.Group();
            scene.add(earthGroup);

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 1.6);
            scene.add(hemiLight);

            new RGBELoader()
                .load('https://threejs.org/examples/textures/equirectangular/royal_esplanade_1k.hdr', function(texture) {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.environment = texture;
                });

            createEarth();
            createAurora();
            createStars();
            createLandmarks();
            createRealisticUFO();

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5.5; 
            controls.maxDistance = 30;
            controls.rotateSpeed = 0.5;

            window.addEventListener('resize', onWindowResize);
            
            // --- UI 與 音效啟動 ---
            const peaceBtn = document.getElementById('peace-btn');
            const fireBtn = document.getElementById('fire-btn');

            peaceBtn.addEventListener('click', () => {
                initAudio(); // 啟動音效引擎
                isWarActive = false;
                if(warInterval) clearInterval(warInterval);
                
                peaceBtn.classList.add('active');
                fireBtn.classList.remove('active');
            });

            fireBtn.addEventListener('click', () => {
                initAudio(); // 啟動音效引擎
                if (isWarActive) return;
                isWarActive = true;
                
                fireBtn.classList.add('active');
                peaceBtn.classList.remove('active');
                
                // 自動轉向亞洲
                const targetPos = latLongToVector3(25, 120, 16);
                camera.position.lerp(targetPos, 0.8);
                
                startNuclearWar();
            });

            setTimeout(() => {
                const el = document.getElementById('loading');
                if(el) el.style.opacity = 0;
                setTimeout(() => { if(el) el.style.display = 'none'; }, 500);
            }, 1000);
        }

        function startNuclearWar() {
            if(!isWarActive) return;
            if(warInterval) clearInterval(warInterval); 
            
            warInterval = setInterval(() => {
                if(!isWarActive) {
                    clearInterval(warInterval);
                    return;
                }
                
                const attackerIdx = Math.floor(Math.random() * landmarksData.length);
                let victimIdx = Math.floor(Math.random() * landmarksData.length);
                while(attackerIdx === victimIdx) {
                    victimIdx = Math.floor(Math.random() * landmarksData.length);
                }
                launchMissile(landmarksData[attackerIdx], landmarksData[victimIdx], false);

                const taiwan = landmarksData.find(d => d.name.includes("台灣"));
                const chinaTargets = landmarksData.filter(d => d.region === 'ChinaTarget');
                
                if (taiwan && chinaTargets.length > 0) {
                    const randomChinaTarget = chinaTargets[Math.floor(Math.random() * chinaTargets.length)];
                    launchMissile(taiwan, randomChinaTarget, true); 
                }

            }, 1200); 
        }

        function launchMissile(startLocation, endLocation, isSuper = false) {
            const startPos = latLongToVector3(startLocation.lat, startLocation.lon, CONFIG.earthRadius);
            const endPos = latLongToVector3(endLocation.lat, endLocation.lon, CONFIG.earthRadius);

            const heightBoost = isSuper ? 4.5 : 2.0 + Math.random() * 1.5;
            const midPoint = startPos.clone().add(endPos).normalize().multiplyScalar(CONFIG.earthRadius + heightBoost);
            
            const curve = new THREE.QuadraticBezierCurve3(startPos, midPoint, endPos);
            const points = curve.getPoints(50);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            
            const material = new THREE.LineBasicMaterial({ 
                color: isSuper ? 0xff3300 : 0xffaa00, 
                transparent: true, 
                opacity: isSuper ? 0.9 : 0.4,
                linewidth: isSuper ? 6 : 2
            });
            const trajectory = new THREE.Line(geometry, material);
            earthGroup.add(trajectory);

            const size = isSuper ? 0.15 : 0.04;
            const missileGeo = new THREE.SphereGeometry(size, 8, 8);
            const missileMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const missile = new THREE.Mesh(missileGeo, missileMat);
            
            if(isSuper) {
                const glowMat = new THREE.MeshBasicMaterial({color: 0xff0000, transparent:true, opacity:0.6});
                const glow = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), glowMat);
                missile.add(glow);
            }

            earthGroup.add(missile);

            activeMissiles.push({
                mesh: missile,
                trail: trajectory,
                curve: curve,
                progress: 0,
                speed: isSuper ? 0.002 : 0.003 + Math.random() * 0.002, 
                targetPos: endPos,
                isSuper: isSuper
            });
        }

        function createExplosion(position, isSuper = false) {
            const multiplier = isSuper ? 8 : 1; 

            // 播放音效
            playExplosionSound(isSuper);

            const ringGeo = new THREE.RingGeometry(0.05 * multiplier, 0.1 * multiplier, 32);
            const ringMat = new THREE.MeshBasicMaterial({ 
                color: isSuper ? 0xff2200 : 0xffaa00, 
                transparent: true, 
                opacity: 0.8, 
                side: THREE.DoubleSide 
            });
            const shockwave = new THREE.Mesh(ringGeo, ringMat);
            shockwave.position.copy(position);
            shockwave.lookAt(0,0,0);
            earthGroup.add(shockwave);

            activeExplosions.push({
                shockwave: shockwave,
                age: 0,
                maxAge: isSuper ? 200 : 100, 
                multiplier: multiplier
            });

            setTimeout(() => createMushroomCloud(position, isSuper), 50);
        }

        function createMushroomCloud(position, isSuper = false) {
            const group = new THREE.Group();
            group.position.copy(position);
            const up = position.clone().normalize();
            group.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), up);

            const material = new THREE.MeshStandardMaterial({
                color: isSuper ? 0x222222 : 0x444444,
                emissive: isSuper ? 0xdd0000 : 0xcc2200,
                emissiveIntensity: isSuper ? 1.0 : 0.5,
                roughness: 1,
                flatShading: true
            });

            const stemGeo = new THREE.CylinderGeometry(0.02, 0.01, 0.3, 8);
            stemGeo.translate(0, 0.15, 0);
            const stem = new THREE.Mesh(stemGeo, material);
            
            const capGeo = new THREE.DodecahedronGeometry(0.15, 1);
            capGeo.translate(0, 0.3, 0);
            const cap = new THREE.Mesh(capGeo, material);

            group.add(stem);
            group.add(cap);
            group.scale.set(0.1, 0.1, 0.1); 

            earthGroup.add(group);

            activeMushrooms.push({
                group: group,
                material: material,
                age: 0,
                maxAge: isSuper ? 1500 : 800, 
                isSuper: isSuper
            });
        }

        function createEarth() {
            const geometry = new THREE.SphereGeometry(CONFIG.earthRadius, 128, 128);
            const material = new THREE.MeshStandardMaterial({
                map: textureLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg'),
                normalMap: textureLoader.load('https://threejs.org/examples/textures/planets/earth_normal_2048.jpg'),
                normalScale: new THREE.Vector2(0.8, 0.8),
                roughness: 0.6,
                metalness: 0.05
            });
            earthMesh = new THREE.Mesh(geometry, material);
            earthMesh.rotation.y = -Math.PI / 2;
            earthGroup.add(earthMesh);

            const cloudGeo = new THREE.SphereGeometry(CONFIG.earthRadius + 0.06, 128, 128);
            const cloudMat = new THREE.MeshStandardMaterial({
                map: textureLoader.load('https://threejs.org/examples/textures/planets/earth_clouds_1024.png'),
                transparent: true, opacity: 0.5, depthWrite: false, side: THREE.DoubleSide
            });
            cloudMesh = new THREE.Mesh(cloudGeo, cloudMat);
            cloudMesh.rotation.y = -Math.PI / 2; 
            earthGroup.add(cloudMesh);
            
            const atmosGeo = new THREE.SphereGeometry(CONFIG.earthRadius + 1.25, 64, 64);
            const atmosMat = new THREE.ShaderMaterial({
                uniforms: {
                    c: { type: "f", value: 0.6 }, p: { type: "f", value: 4.0 },
                    glowColor: { type: "c", value: new THREE.Color(0x2266cc) }, 
                    viewVector: { type: "v3", value: camera.position }
                },
                vertexShader: `
                    uniform vec3 viewVector; varying float intensity;
                    void main() {
                        vec3 vNormal = normalize( normalMatrix * normal );
                        vec3 vNormel = normalize( normalMatrix * viewVector );
                        intensity = pow( 0.65 - dot(vNormal, vNormel), 4.0 ); 
                        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                    } 
                `,
                fragmentShader: `
                    uniform vec3 glowColor; varying float intensity;
                    void main() { vec3 glow = glowColor * intensity; gl_FragColor = vec4( glow, 1.0 ); }
                `,
                side: THREE.BackSide, blending: THREE.AdditiveBlending, transparent: true
            });
            scene.add(new THREE.Mesh(atmosGeo, atmosMat));
        }

        function createLandmarks() {
            landmarksData.forEach(data => {
                let mesh = null;
                const matStone = new THREE.MeshStandardMaterial({ color: 0xeeddaa, roughness: 0.6 });
                const matGrey = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.4 });
                const matWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 });

                switch(data.type) {
                    case 'pyramid': mesh = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.15, 4), matStone); break;
                    case 'pyramid_step': 
                        mesh = new THREE.Group();
                        for(let i=0; i<3; i++) {
                            const b = new THREE.Mesh(new THREE.BoxGeometry(0.12-i*0.03, 0.03, 0.12-i*0.03), matGrey);
                            b.position.y = i*0.03; mesh.add(b);
                        } break;
                    case 'wall': 
                        mesh = new THREE.Group();
                        for(let i=0; i<6; i++) {
                            const p = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.03, 0.08), matGrey);
                            p.position.set(i*0.03, 0, 0); mesh.add(p);
                        } break;
                    case 'colosseum':
                        const t = new THREE.TorusGeometry(0.06, 0.02, 4, 12); t.rotateX(Math.PI/2);
                        mesh = new THREE.Mesh(t, matStone); break;
                    case 'stonehenge':
                        mesh = new THREE.Group();
                        for(let i=0; i<5; i++) {
                            const st = new THREE.Mesh(new THREE.BoxGeometry(0.015, 0.04, 0.015), matGrey);
                            st.position.set(Math.cos(i)*0.04, 0.02, Math.sin(i)*0.04); mesh.add(st);
                        } break;
                    case 'needle': mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.02, 0.3, 8), matWhite); mesh.position.y = 0.15; break;
                    case 'tower': mesh = new THREE.Mesh(new THREE.ConeGeometry(0.03, 0.2, 4), matStone); mesh.position.y = 0.1; break;
                    case 'statue': case 'moai': mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.03, 0.15, 6), matGrey); mesh.position.y = 0.07; break;
                    case 'dome': 
                        mesh = new THREE.Group();
                        mesh.add(new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 8, 0, Math.PI*2, 0, Math.PI/2), matWhite));
                        mesh.position.y = 0.03; break;
                    case 'mountain': mesh = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.1, 16), matWhite); break;
                    case 'temple': mesh = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, 0.05), matStone); break;
                    case 'sails': mesh = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.12, 4), matWhite); mesh.rotation.z = -0.3; break;
                    case 'cross': 
                        mesh = new THREE.Group();
                        mesh.add(new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.1, 0.02), matWhite));
                        const a = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.02, 0.02), matWhite); a.position.y = 0.02; mesh.add(a);
                        mesh.position.y = 0.05; break;
                    case 'atlantis': 
                        mesh = new THREE.Mesh(new THREE.OctahedronGeometry(0.15), new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true })); break;
                    default: mesh = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.04), matGrey);
                }

                if (mesh) {
                    const pos = latLongToVector3(data.lat, data.lon, CONFIG.earthRadius);
                    mesh.position.copy(pos);
                    mesh.lookAt(0, 0, 0); 
                    const normal = pos.clone().normalize();
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), normal);
                    mesh.quaternion.copy(quaternion);
                    if(data.type === 'wall') mesh.rotateY(Math.PI/2);
                    earthGroup.add(mesh);
                    
                    const div = document.createElement('div');
                    div.className = 'label';
                    div.innerHTML = `<strong>${data.name}</strong>`;
                    document.getElementById('labels-container').appendChild(div);
                    markers.push({ mesh: mesh, dom: div });
                }
            });
        }

        function createRealisticUFO() {
            ufoGroup = new THREE.Group();
            const hull = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.15, 0.04, 32), new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9, roughness: 0.2 }));
            const ring = new THREE.Mesh(new THREE.TorusGeometry(0.15, 0.01, 8, 32), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
            ring.rotation.x = Math.PI/2;
            ufoGroup.add(hull, ring);
            scene.add(ufoGroup);
        }

        function createAurora() {
            auroraGroup = new THREE.Group();
            const auroraGeo = new THREE.CylinderGeometry(CONFIG.earthRadius + 0.1, CONFIG.earthRadius + 0.5, 1.8, 64, 16, true);
            auroraGeo.translate(0, CONFIG.earthRadius * 0.95, 0);
            const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`;
            const fragmentShader = `
                uniform float time; uniform vec3 color; varying vec2 vUv;
                float noise(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453); }
                void main() {
                    float n = noise(vec2(vUv.x * 15.0 + time * 0.3, vUv.y * 2.0));
                    gl_FragColor = vec4(color, smoothstep(0.0, 0.4, vUv.y) * smoothstep(1.0, 0.4, vUv.y) * n * 0.8 + 0.1);
                }
            `;
            const matNorth = new THREE.ShaderMaterial({ uniforms: { time: { value: 0 }, color: { value: new THREE.Color(0x00ffcc) } }, vertexShader, fragmentShader, transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false });
            const matSouth = new THREE.ShaderMaterial({ uniforms: { time: { value: 0 }, color: { value: new THREE.Color(0xaa55ff) } }, vertexShader, fragmentShader, transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false });
            const north = new THREE.Mesh(auroraGeo, matNorth);
            const south = new THREE.Mesh(auroraGeo, matSouth);
            south.rotation.x = Math.PI;
            auroraGroup.add(north, south);
            earthGroup.add(auroraGroup);
        }

        function createStars() {
            const starGeo = new THREE.BufferGeometry();
            const count = 3500;
            const pos = new Float32Array(count * 3);
            for(let i=0; i<count*3; i++) pos[i] = (Math.random()-0.5) * 800;
            starGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.8, transparent: true, opacity: 0.8 });
            scene.add(new THREE.Points(starGeo, starMat));
        }

        function latLongToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon) * (Math.PI / 180); 
            const x = radius * Math.sin(phi) * Math.sin(theta);
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.cos(theta);
            return new THREE.Vector3(x, y, z);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            earthGroup.rotation.y += 0.0003;
            if (cloudMesh) cloudMesh.rotation.y = -Math.PI / 2 + time * 0.003;
            if (auroraGroup) auroraGroup.children.forEach(mesh => mesh.material.uniforms.time.value = time);

            if (ufoGroup) {
                const r = CONFIG.earthRadius + 1.2;
                ufoGroup.position.set(Math.sin(time*0.8)*r, Math.cos(time*0.5)*2, Math.cos(time*0.8)*r);
                ufoGroup.lookAt(0,0,0);
            }

            for (let i = activeMissiles.length - 1; i >= 0; i--) {
                const m = activeMissiles[i];
                m.progress += m.speed;
                if (m.progress >= 1) {
                    createExplosion(m.targetPos, m.isSuper);
                    earthGroup.remove(m.mesh);
                    earthGroup.remove(m.trail);
                    activeMissiles.splice(i, 1);
                } else {
                    const pos = m.curve.getPoint(m.progress);
                    m.mesh.position.copy(pos);
                }
            }

            for (let i = activeExplosions.length - 1; i >= 0; i--) {
                const e = activeExplosions[i];
                e.age++;
                const baseScale = 1 + (e.age / 10);
                const scale = baseScale * e.multiplier;
                
                e.shockwave.scale.set(scale * 1.5, scale * 1.5, 1);
                e.shockwave.material.opacity = (1 - (e.age / e.maxAge)) * 0.8;
                
                if (e.age >= e.maxAge) {
                    earthGroup.remove(e.shockwave);
                    activeExplosions.splice(i, 1);
                }
            }

            for (let i = activeMushrooms.length - 1; i >= 0; i--) {
                const m = activeMushrooms[i];
                m.age++;
                const growSpeed = m.isSuper ? 80 : 40; 
                const maxScale = m.isSuper ? 15.0 : 2.5; 
                
                if (m.age < growSpeed) {
                    const growth = Math.min(m.age / growSpeed, 1) * maxScale; 
                    m.group.scale.set(growth, growth, growth);
                }
                if (m.age > growSpeed) {
                    m.material.emissiveIntensity = Math.max(0, (m.isSuper ? 1.0 : 0.5) - (m.age - growSpeed) * 0.005);
                }
                if (m.age >= m.maxAge) {
                    m.group.scale.multiplyScalar(0.99); 
                    if (m.group.scale.x < 0.1) {
                        earthGroup.remove(m.group);
                        activeMushrooms.splice(i, 1);
                    }
                }
            }

            markers.forEach(marker => {
                const worldPos = new THREE.Vector3();
                marker.mesh.getWorldPosition(worldPos);
                const dist = worldPos.distanceTo(camera.position);
                if (dist < camera.position.length() + 0.5) {
                    const screenPos = worldPos.clone().project(camera);
                    const x = (screenPos.x * .5 + .5) * window.innerWidth;
                    const y = (screenPos.y * -.5 + .5) * window.innerHeight;
                    if(x>0 && x<window.innerWidth && y>0 && y<window.innerHeight) {
                        marker.dom.style.left = `${x}px`;
                        marker.dom.style.top = `${y}px`;
                        marker.dom.classList.add('visible');
                    } else marker.dom.classList.remove('visible');
                } else marker.dom.classList.remove('visible');
            });

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>


