<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D 地球儀 - 核戰末日模擬</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; }
        
        .label {
            position: absolute;
            color: #ffffff;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 2px;
            font-size: 12px; 
            border-bottom: 2px solid #4db8ff;
            pointer-events: none;
            transform: translate(-50%, -20px);
            opacity: 0;
            transition: opacity 0.3s;
            white-space: nowrap;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            z-index: 10;
        }
        .label.visible { opacity: 1; }
        .label strong { display: block; font-size: 1.1em; color: #4db8ff; margin-bottom: 2px; font-weight: 600; }
        
        .label::after {
            content: '';
            position: absolute;
            bottom: -15px;
            left: 50%;
            width: 1px;
            height: 15px;
            background: linear-gradient(to bottom, #4db8ff, transparent);
        }

        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #ff3333; font-family: 'Courier New', Courier, monospace;
            background: rgba(20,0,0,0.9); padding: 15px 30px; border-radius: 4px;
            pointer-events: none;
            z-index: 20;
            border: 1px solid #ff3333;
            letter-spacing: 1px;
            text-transform: uppercase;
            font-size: 14px;
            text-shadow: 0 0 5px red;
        }

        #war-btn {
            position: absolute; bottom: 30px; left: 50%;
            transform: translateX(-50%);
            background: rgba(50, 0, 0, 0.8);
            color: #ff4444;
            border: 1px solid #ff4444;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            cursor: pointer;
            z-index: 30;
            letter-spacing: 2px;
            transition: 0.3s;
        }
        #war-btn:hover { background: #ff4444; color: black; box-shadow: 0 0 15px #ff0000; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    
    <div id="labels-container"></div>
    <div id="loading">SYSTEM WARNING: NUCLEAR LAUNCH DETECTED...</div>
    <button id="war-btn">INITIATE LAUNCH SEQUENCE</button>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        const CONFIG = { earthRadius: 5 };

        let scene, camera, renderer, controls;
        let earthGroup, earthMesh, cloudMesh, ufoGroup, auroraGroup;
        const markers = [];
        const activeMissiles = [];
        const activeExplosions = [];
        const activeMushrooms = [];
        
        const clock = new THREE.Clock();
        const textureLoader = new THREE.TextureLoader();
        let isWarActive = false;

        // 核武國家座標 (發射源與目標)
        const nuclearTargets = [
            { name: "Washington DC", lat: 38.9072, lon: -77.0369 },
            { name: "Moscow", lat: 55.7558, lon: 37.6173 },
            { name: "Beijing", lat: 39.9042, lon: 116.4074 },
            { name: "London", lat: 51.5074, lon: -0.1278 },
            { name: "Paris", lat: 48.8566, lon: 2.3522 },
            { name: "New Delhi", lat: 28.6139, lon: 77.2090 },
            { name: "Pyongyang", lat: 39.0392, lon: 125.7625 },
            { name: "Tel Aviv", lat: 32.0853, lon: 34.7818 },
            { name: "Taipei", lat: 25.0330, lon: 121.5654 }, // 戰略要地
            { name: "Tokyo", lat: 35.6762, lon: 139.6503 },
            { name: "Berlin", lat: 52.5200, lon: 13.4050 },
            { name: "Tehran", lat: 35.6892, lon: 51.3890 }
        ];

        const landmarksData = [
            { name: "埃及金字塔", lat: 29.9792, lon: 31.1342, type: 'pyramid' },
            { name: "萬里長城", lat: 40.4319, lon: 116.5704, type: 'wall' }, 
            { name: "台灣 (台北101)", lat: 25.0330, lon: 121.5654, type: 'needle' },
            { name: "艾菲爾鐵塔", lat: 48.8584, lon: 2.2945, type: 'tower' },
            { name: "自由女神像", lat: 40.6892, lon: -74.0445, type: 'statue' },
            { name: "克里姆林宮", lat: 55.7520, lon: 37.6173, type: 'dome' }
        ];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 16);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);

            earthGroup = new THREE.Group();
            scene.add(earthGroup);

            // --- 燈光系統 ---
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 1.6);
            scene.add(hemiLight);

            new RGBELoader()
                .load('https://threejs.org/examples/textures/equirectangular/royal_esplanade_1k.hdr', function(texture) {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.environment = texture;
                });

            createEarth();
            createAurora();
            createStars();
            createLandmarks();
            // createRealisticUFO(); // 戰時隱藏 UFO 避免畫面太亂

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5.5; 
            controls.maxDistance = 30;
            controls.rotateSpeed = 0.5;

            window.addEventListener('resize', onWindowResize);
            
            document.getElementById('war-btn').addEventListener('click', () => {
                isWarActive = !isWarActive;
                const btn = document.getElementById('war-btn');
                if(isWarActive) {
                    btn.innerText = "CEASE FIRE";
                    btn.style.background = "#ff0000";
                    btn.style.color = "white";
                    startNuclearWar();
                } else {
                    btn.innerText = "INITIATE LAUNCH SEQUENCE";
                    btn.style.background = "rgba(50, 0, 0, 0.8)";
                    btn.style.color = "#ff4444";
                }
            });

            setTimeout(() => {
                const el = document.getElementById('loading');
                if(el) el.style.opacity = 0;
                setTimeout(() => { if(el) el.style.display = 'none'; }, 500);
            }, 1000);
        }

        // --- 核戰邏輯 ---
        function startNuclearWar() {
            if(!isWarActive) return;
            
            // 隨機發射導彈
            const launchInterval = setInterval(() => {
                if(!isWarActive) {
                    clearInterval(launchInterval);
                    return;
                }
                
                // 隨機選取攻擊方與受害方
                const attackerIdx = Math.floor(Math.random() * nuclearTargets.length);
                let victimIdx = Math.floor(Math.random() * nuclearTargets.length);
                while(attackerIdx === victimIdx) {
                    victimIdx = Math.floor(Math.random() * nuclearTargets.length);
                }

                const start = nuclearTargets[attackerIdx];
                const end = nuclearTargets[victimIdx];

                launchMissile(start, end);

            }, 800); // 每 0.8 秒發射一枚
        }

        function launchMissile(startLocation, endLocation) {
            const startPos = latLongToVector3(startLocation.lat, startLocation.lon, CONFIG.earthRadius);
            const endPos = latLongToVector3(endLocation.lat, endLocation.lon, CONFIG.earthRadius);

            // 計算貝茲曲線控制點 (讓導彈飛出大氣層)
            const midPoint = startPos.clone().add(endPos).normalize().multiplyScalar(CONFIG.earthRadius + 2.5 + Math.random() * 2);
            
            const curve = new THREE.QuadraticBezierCurve3(startPos, midPoint, endPos);
            const points = curve.getPoints(50);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            
            // 導彈軌跡線
            const material = new THREE.LineBasicMaterial({ 
                color: 0xffaa00, 
                transparent: true, 
                opacity: 0.5,
                linewidth: 2 
            });
            const trajectory = new THREE.Line(geometry, material);
            earthGroup.add(trajectory);

            // 導彈本體 (發光粒子)
            const missileGeo = new THREE.SphereGeometry(0.05, 8, 8);
            const missileMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const missile = new THREE.Mesh(missileGeo, missileMat);
            earthGroup.add(missile);

            activeMissiles.push({
                mesh: missile,
                trail: trajectory,
                curve: curve,
                progress: 0,
                speed: 0.01 + Math.random() * 0.01,
                targetPos: endPos
            });
        }

        function createExplosion(position) {
            // 1. 閃光球體 (快速擴散)
            const geometry = new THREE.SphereGeometry(0.1, 32, 32);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xff5500, // 紅橙色
                transparent: true, 
                opacity: 1.0 
            });
            const explosion = new THREE.Mesh(geometry, material);
            explosion.position.copy(position);
            earthGroup.add(explosion);

            // 2. 衝擊波環
            const ringGeo = new THREE.RingGeometry(0.05, 0.1, 32);
            const ringMat = new THREE.MeshBasicMaterial({ 
                color: 0xffaa00, 
                transparent: true, 
                opacity: 0.8, 
                side: THREE.DoubleSide 
            });
            const shockwave = new THREE.Mesh(ringGeo, ringMat);
            shockwave.position.copy(position);
            shockwave.lookAt(0,0,0); // 面向地心
            earthGroup.add(shockwave);

            activeExplosions.push({
                mesh: explosion,
                shockwave: shockwave,
                age: 0,
                maxAge: 60 // 存活幀數
            });

            // 觸發蕈菇雲
            setTimeout(() => createMushroomCloud(position), 200);
        }

        function createMushroomCloud(position) {
            const group = new THREE.Group();
            group.position.copy(position);
            
            // 讓蕈菇雲垂直於地表
            const up = position.clone().normalize();
            group.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), up);

            // 蕈菇雲材質 (深灰帶紅光)
            const material = new THREE.MeshStandardMaterial({
                color: 0x444444,
                emissive: 0xff2200,
                emissiveIntensity: 0.8,
                roughness: 1,
                flatShading: true
            });

            // 蕈菇莖
            const stemGeo = new THREE.CylinderGeometry(0.02, 0.01, 0.3, 8);
            stemGeo.translate(0, 0.15, 0);
            const stem = new THREE.Mesh(stemGeo, material);
            
            // 蕈菇蓋
            const capGeo = new THREE.DodecahedronGeometry(0.15, 1); // 使用多面體更有煙霧感
            capGeo.translate(0, 0.3, 0);
            const cap = new THREE.Mesh(capGeo, material);

            group.add(stem);
            group.add(cap);
            group.scale.set(0.1, 0.1, 0.1); // 初始很小

            earthGroup.add(group);

            activeMushrooms.push({
                group: group,
                material: material,
                age: 0,
                maxAge: 300 // 存活很久
            });
        }

        // --- 基礎 3D 建置 (保持 NASA 質感) ---
        function createEarth() {
            const geometry = new THREE.SphereGeometry(CONFIG.earthRadius, 128, 128);
            const material = new THREE.MeshStandardMaterial({
                map: textureLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg'),
                normalMap: textureLoader.load('https://threejs.org/examples/textures/planets/earth_normal_2048.jpg'),
                normalScale: new THREE.Vector2(0.8, 0.8),
                roughness: 0.6,
                metalness: 0.05
            });
            earthMesh = new THREE.Mesh(geometry, material);
            earthMesh.rotation.y = -Math.PI / 2;
            earthGroup.add(earthMesh);

            const cloudGeo = new THREE.SphereGeometry(CONFIG.earthRadius + 0.06, 128, 128);
            const cloudMat = new THREE.MeshStandardMaterial({
                map: textureLoader.load('https://threejs.org/examples/textures/planets/earth_clouds_1024.png'),
                transparent: true, opacity: 0.5, depthWrite: false, side: THREE.DoubleSide
            });
            cloudMesh = new THREE.Mesh(cloudGeo, cloudMat);
            cloudMesh.rotation.y = -Math.PI / 2; 
            earthGroup.add(cloudMesh);
            
            const atmosGeo = new THREE.SphereGeometry(CONFIG.earthRadius + 1.25, 64, 64);
            const atmosMat = new THREE.ShaderMaterial({
                uniforms: {
                    c: { type: "f", value: 0.6 }, p: { type: "f", value: 4.0 },
                    glowColor: { type: "c", value: new THREE.Color(0x2266cc) }, 
                    viewVector: { type: "v3", value: camera.position }
                },
                vertexShader: `
                    uniform vec3 viewVector; varying float intensity;
                    void main() {
                        vec3 vNormal = normalize( normalMatrix * normal );
                        vec3 vNormel = normalize( normalMatrix * viewVector );
                        intensity = pow( 0.65 - dot(vNormal, vNormel), 4.0 ); 
                        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                    } 
                `,
                fragmentShader: `
                    uniform vec3 glowColor; varying float intensity;
                    void main() { vec3 glow = glowColor * intensity; gl_FragColor = vec4( glow, 1.0 ); }
                `,
                side: THREE.BackSide, blending: THREE.AdditiveBlending, transparent: true
            });
            scene.add(new THREE.Mesh(atmosGeo, atmosMat));
        }

        function createLandmarks() {
            landmarksData.forEach(data => {
                let mesh = null;
                const matStone = new THREE.MeshStandardMaterial({ color: 0xeeddaa, roughness: 0.6 });
                const matGrey = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.4 });
                const matWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 });

                switch(data.type) {
                    case 'pyramid': mesh = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.15, 4), matStone); break;
                    case 'wall': 
                        mesh = new THREE.Group();
                        for(let i=0; i<8; i++) {
                            const p = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.1), matGrey);
                            p.position.set(i*0.03, 0, 0); mesh.add(p);
                        }
                        break;
                    case 'needle': mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.02, 0.4, 8), matWhite); mesh.position.y = 0.2; break;
                    case 'tower': mesh = new THREE.Mesh(new THREE.ConeGeometry(0.04, 0.3, 4), matStone); mesh.position.y = 0.1; break;
                    case 'statue': mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.03, 0.15, 6), matGrey); mesh.position.y = 0.07; break;
                    case 'dome': mesh = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8, 0, Math.PI*2, 0, Math.PI/2), matWhite); break;
                    default: mesh = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 0.05), matGrey);
                }

                if (mesh) {
                    const pos = latLongToVector3(data.lat, data.lon, CONFIG.earthRadius);
                    mesh.position.copy(pos);
                    mesh.lookAt(0, 0, 0); 
                    const normal = pos.clone().normalize();
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), normal);
                    mesh.quaternion.copy(quaternion);
                    if(data.type === 'wall') mesh.rotateY(Math.PI/2);
                    earthGroup.add(mesh);
                    
                    const div = document.createElement('div');
                    div.className = 'label';
                    div.innerHTML = `<strong>${data.name}</strong>`;
                    document.getElementById('labels-container').appendChild(div);
                    markers.push({ mesh: mesh, dom: div });
                }
            });
        }

        function createAurora() {
            auroraGroup = new THREE.Group();
            const auroraGeo = new THREE.CylinderGeometry(CONFIG.earthRadius + 0.1, CONFIG.earthRadius + 0.5, 1.8, 64, 16, true);
            auroraGeo.translate(0, CONFIG.earthRadius * 0.95, 0);
            const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`;
            const fragmentShader = `
                uniform float time; uniform vec3 color; varying vec2 vUv;
                float noise(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453); }
                void main() {
                    float n = noise(vec2(vUv.x * 15.0 + time * 0.3, vUv.y * 2.0));
                    gl_FragColor = vec4(color, smoothstep(0.0, 0.4, vUv.y) * smoothstep(1.0, 0.4, vUv.y) * n * 0.8 + 0.1);
                }
            `;
            const matNorth = new THREE.ShaderMaterial({ uniforms: { time: { value: 0 }, color: { value: new THREE.Color(0x00ffcc) } }, vertexShader, fragmentShader, transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false });
            const matSouth = new THREE.ShaderMaterial({ uniforms: { time: { value: 0 }, color: { value: new THREE.Color(0xaa55ff) } }, vertexShader, fragmentShader, transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false });
            const north = new THREE.Mesh(auroraGeo, matNorth);
            const south = new THREE.Mesh(auroraGeo, matSouth);
            south.rotation.x = Math.PI;
            auroraGroup.add(north, south);
            earthGroup.add(auroraGroup);
        }

        function createStars() {
            const starGeo = new THREE.BufferGeometry();
            const count = 3500;
            const pos = new Float32Array(count * 3);
            for(let i=0; i<count*3; i++) pos[i] = (Math.random()-0.5) * 800;
            starGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.8, transparent: true, opacity: 0.8 });
            scene.add(new THREE.Points(starGeo, starMat));
        }

        function latLongToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon) * (Math.PI / 180); 
            const x = radius * Math.sin(phi) * Math.sin(theta);
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.cos(theta);
            return new THREE.Vector3(x, y, z);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            earthGroup.rotation.y += 0.0005;
            if (cloudMesh) cloudMesh.rotation.y = -Math.PI / 2 + time * 0.005;
            if (auroraGroup) auroraGroup.children.forEach(mesh => mesh.material.uniforms.time.value = time);

            // 更新導彈
            for (let i = activeMissiles.length - 1; i >= 0; i--) {
                const m = activeMissiles[i];
                m.progress += m.speed;
                if (m.progress >= 1) {
                    // 擊中目標
                    createExplosion(m.targetPos);
                    earthGroup.remove(m.mesh);
                    earthGroup.remove(m.trail);
                    activeMissiles.splice(i, 1);
                } else {
                    const pos = m.curve.getPoint(m.progress);
                    m.mesh.position.copy(pos);
                }
            }

            // 更新爆炸效果
            for (let i = activeExplosions.length - 1; i >= 0; i--) {
                const e = activeExplosions[i];
                e.age++;
                const scale = 1 + (e.age / 10);
                e.mesh.scale.set(scale, scale, scale);
                e.mesh.material.opacity = 1 - (e.age / e.maxAge);
                
                e.shockwave.scale.set(scale * 1.5, scale * 1.5, 1);
                e.shockwave.material.opacity = 1 - (e.age / e.maxAge);

                if (e.age >= e.maxAge) {
                    earthGroup.remove(e.mesh);
                    earthGroup.remove(e.shockwave);
                    activeExplosions.splice(i, 1);
                }
            }

            // 更新蕈菇雲
            for (let i = activeMushrooms.length - 1; i >= 0; i--) {
                const m = activeMushrooms[i];
                m.age++;
                
                // 生長動畫：變大並往上升
                if (m.age < 100) {
                    const growth = Math.min(m.age / 50, 1) * 2.5; // 最大倍率
                    m.group.scale.set(growth, growth, growth);
                }

                // 顏色變化：從紅光(emissive) 變冷卻的灰煙
                if (m.age > 50) {
                    m.material.emissiveIntensity = Math.max(0, 0.8 - (m.age - 50) * 0.01);
                }

                // 慢慢消失
                if (m.age >= m.maxAge) {
                    m.group.scale.multiplyScalar(0.98); // 縮小消失
                    if (m.group.scale.x < 0.1) {
                        earthGroup.remove(m.group);
                        activeMushrooms.splice(i, 1);
                    }
                }
            }

            // 更新標籤位置
            markers.forEach(marker => {
                const worldPos = new THREE.Vector3();
                marker.mesh.getWorldPosition(worldPos);
                const dist = worldPos.distanceTo(camera.position);
                if (dist < camera.position.length() + 0.5) {
                    const screenPos = worldPos.clone().project(camera);
                    const x = (screenPos.x * .5 + .5) * window.innerWidth;
                    const y = (screenPos.y * -.5 + .5) * window.innerHeight;
                    if(x>0 && x<window.innerWidth && y>0 && y<window.innerHeight) {
                        marker.dom.style.left = `${x}px`;
                        marker.dom.style.top = `${y}px`;
                        marker.dom.classList.add('visible');
                    } else marker.dom.classList.remove('visible');
                } else marker.dom.classList.remove('visible');
            });

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
