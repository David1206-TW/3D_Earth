<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D 地球儀 - 終極戰略版</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Segoe UI', sans-serif; }
        
        /* 標籤樣式 */
        .label {
            position: absolute;
            color: #ffffff;
            background: rgba(0, 15, 30, 0.7);
            padding: 4px 8px;
            border-radius: 2px;
            font-size: 11px; 
            border-bottom: 1px solid #4db8ff;
            pointer-events: none;
            transform: translate(-50%, -20px);
            opacity: 0;
            transition: opacity 0.3s;
            white-space: nowrap;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            z-index: 10;
        }
        .label.visible { opacity: 1; }
        .label strong { display: block; font-size: 1.1em; color: #4db8ff; margin-bottom: 2px; font-weight: 600; }
        .label.iss { border-top: 2px solid #00ff00; border-bottom: none; background: rgba(0, 20, 0, 0.8); }
        .label.iss strong { color: #00ff00; }
        
        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #4db8ff; font-family: 'Courier New', Courier, monospace;
            background: rgba(0,20,40,0.9); padding: 10px 20px; border-radius: 4px;
            pointer-events: none; z-index: 20; border: 1px solid #4db8ff;
            text-transform: uppercase; font-size: 12px; text-shadow: 0 0 5px #4db8ff;
        }

        /* --- UI 容器 --- */
        #ui-container {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 30;
        }

        .control-btn {
            background: rgba(10, 15, 20, 0.8);
            border: 1px solid #555;
            color: #aaa;
            padding: 12px 30px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            backdrop-filter: blur(5px);
        }

        #peace-btn.active, #peace-btn:hover {
            border-color: #00ffaa; color: #00ffaa;
            box-shadow: 0 0 15px rgba(0, 255, 170, 0.4);
            background: rgba(0, 40, 20, 0.8);
        }

        #fire-btn.active, #fire-btn:hover {
            border-color: #ff3333; color: #ff3333;
            box-shadow: 0 0 20px rgba(255, 51, 51, 0.6);
            background: rgba(60, 0, 0, 0.8);
        }

    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    
    <div id="labels-container"></div>
    <div id="loading">SYSTEM READY...</div>
    
    <div id="ui-container">
        <button id="peace-btn" class="control-btn active">PEACE</button>
        <button id="fire-btn" class="control-btn">FIRE</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        const CONFIG = { earthRadius: 5 };

        let scene, camera, renderer, controls;
        let earthGroup, earthMesh, cloudMesh, ufoGroup, auroraGroup, issGroup;
        const markers = [];
        const activeMissiles = [];
        const activeExplosions = [];
        const activeMushrooms = [];
        
        const clock = new THREE.Clock();
        const textureLoader = new THREE.TextureLoader();
        let isWarActive = false;
        let warInterval = null;
        let issMarker = null;

        // --- 音效系統 ---
        let audioCtx;
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }
        function playExplosionSound(isSuper) {
            if (!audioCtx) return;
            const t = audioCtx.currentTime;
            const bufferSize = audioCtx.sampleRate * 2.0;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 1000;
            filter.frequency.exponentialRampToValueAtTime(10, t + (isSuper ? 2.5 : 1.0));
            const gain = audioCtx.createGain();
            const volume = isSuper ? 0.8 : 0.1;
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(volume, t + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.01, t + (isSuper ? 2.0 : 0.8));
            noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
            noise.start(t); noise.stop(t + (isSuper ? 3.0 : 1.0));
        }

        // --- 戰略目標資料庫 ---
        const warTargets = [
            // 亞洲
            { name: "台北", lat: 25.0330, lon: 121.5654, region: 'Asia_TW' },
            { name: "北京", lat: 39.9042, lon: 116.4074, region: 'Asia_CN' },
            { name: "上海", lat: 31.2304, lon: 121.4737, region: 'Asia_CN' },
            { name: "東京", lat: 35.6762, lon: 139.6503, region: 'Asia' },
            { name: "首爾", lat: 37.5665, lon: 126.9780, region: 'Asia' },
            { name: "新德里", lat: 28.6139, lon: 77.2090, region: 'Asia' },
            { name: "成都", lat: 30.5728, lon: 104.0668, region: 'Asia_CN' },
            { name: "廣州", lat: 23.1291, lon: 113.2644, region: 'Asia_CN' },
            { name: "雅加達", lat: -6.2088, lon: 106.8456, region: 'Asia' },
            // 歐洲
            { name: "倫敦", lat: 51.5074, lon: -0.1278, region: 'Europe' },
            { name: "巴黎", lat: 48.8566, lon: 2.3522, region: 'Europe' },
            { name: "柏林", lat: 52.5200, lon: 13.4050, region: 'Europe' },
            { name: "羅馬", lat: 41.9028, lon: 12.4964, region: 'Europe' },
            { name: "莫斯科", lat: 55.7558, lon: 37.6173, region: 'Europe' },
            { name: "伊斯坦堡", lat: 41.0082, lon: 28.9784, region: 'Europe' },
            // 美洲
            { name: "紐約", lat: 40.7128, lon: -74.0060, region: 'NA' },
            { name: "華盛頓特區", lat: 38.9072, lon: -77.0369, region: 'NA' },
            { name: "洛杉磯", lat: 34.0522, lon: -118.2437, region: 'NA' },
            { name: "巴西利亞", lat: -15.8267, lon: -47.9218, region: 'SA' },
            { name: "聖保羅", lat: -23.5505, lon: -46.6333, region: 'SA' },
            // 非洲
            { name: "開羅", lat: 30.0444, lon: 31.2357, region: 'Africa' },
            { name: "約翰尼斯堡", lat: -26.2041, lon: 28.0473, region: 'Africa' },
            { name: "拉哥斯", lat: 6.5244, lon: 3.3792, region: 'Africa' },
            // 大洋洲
            { name: "雪梨", lat: -33.8688, lon: 151.2093, region: 'Oceania' },
            { name: "奧克蘭", lat: -36.8485, lon: 174.7633, region: 'Oceania' }
        ];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 16);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);

            earthGroup = new THREE.Group();
            scene.add(earthGroup);

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 1.6);
            scene.add(hemiLight);

            new RGBELoader().load('https://threejs.org/examples/textures/equirectangular/royal_esplanade_1k.hdr', function(texture) {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = texture;
            });

            createEarth();
            createAurora();
            createStars();
            createLandmarks(); 
            createISS(); 
            createRealisticUFO();

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5.5; 
            controls.maxDistance = 30;
            controls.rotateSpeed = 0.5;

            window.addEventListener('resize', onWindowResize);
            
            const peaceBtn = document.getElementById('peace-btn');
            const fireBtn = document.getElementById('fire-btn');

            peaceBtn.addEventListener('click', () => {
                initAudio();
                isWarActive = false;
                if(warInterval) clearInterval(warInterval);
                
                peaceBtn.classList.add('active');
                fireBtn.classList.remove('active');
            });

            fireBtn.addEventListener('click', () => {
                initAudio();
                if (isWarActive) return;
                isWarActive = true;
                fireBtn.classList.add('active');
                peaceBtn.classList.remove('active');
                
                const targetPos = latLongToVector3(25, 120, 16);
                camera.position.lerp(targetPos, 0.8);
                
                startNuclearWar();
            });

            setTimeout(() => {
                const el = document.getElementById('loading');
                if(el) el.style.opacity = 0;
                setTimeout(() => { if(el) el.style.display = 'none'; }, 500);
            }, 1000);
        }

        function createISS() {
            issGroup = new THREE.Group();
            const coreGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8);
            coreGeo.rotateZ(Math.PI / 2);
            const coreMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.4, metalness: 0.8 });
            const core = new THREE.Mesh(coreGeo, coreMat);
            issGroup.add(core);
            const panelGeo = new THREE.BoxGeometry(0.1, 0.01, 0.6);
            const panelMat = new THREE.MeshStandardMaterial({ color: 0x3344cc, roughness: 0.2, metalness: 0.5 });
            const panelLeft = new THREE.Mesh(panelGeo, panelMat);
            panelLeft.position.x = -0.3;
            const panelRight = new THREE.Mesh(panelGeo, panelMat);
            panelRight.position.x = 0.3;
            issGroup.add(panelLeft); issGroup.add(panelRight);
            earthGroup.add(issGroup);
            const div = document.createElement('div');
            div.className = 'label iss';
            div.innerHTML = `<strong>國際太空站</strong>`;
            document.getElementById('labels-container').appendChild(div);
            issMarker = { mesh: issGroup, dom: div, orbitAngle: 0 };
        }

        function createRealisticUFO() {
            ufoGroup = new THREE.Group();
            const scale = 4.0; 
            const hull = new THREE.Mesh(new THREE.CylinderGeometry(0.05*scale, 0.15*scale, 0.04*scale, 32), 
                new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 1.0, roughness: 0.2 }));
            const ring = new THREE.Mesh(new THREE.TorusGeometry(0.15*scale, 0.01*scale, 8, 32), 
                new THREE.MeshBasicMaterial({ color: 0x00ff00 })); 
            ring.rotation.x = Math.PI/2;
            const dome = new THREE.Mesh(new THREE.SphereGeometry(0.06*scale, 16, 16, 0, Math.PI*2, 0, Math.PI/2),
                new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 }));
            dome.position.y = 0.02*scale;
            ufoGroup.add(hull, ring, dome);
            scene.add(ufoGroup);
        }

        function startNuclearWar() {
            if(!isWarActive) return;
            if(warInterval) clearInterval(warInterval); 
            fireRandomMissiles(5); 
            warInterval = setInterval(() => {
                if(!isWarActive) {
                    clearInterval(warInterval);
                    return;
                }
                fireRandomMissiles(Math.floor(Math.random() * 3) + 2);
                const taiwan = warTargets.find(d => d.region === 'Asia_TW');
                const chinaTargets = warTargets.filter(d => d.region === 'Asia_CN');
                if (taiwan && chinaTargets.length > 0) {
                    const target1 = chinaTargets[Math.floor(Math.random() * chinaTargets.length)];
                    launchMissile(taiwan, target1, true); 
                }
            }, 800); 
        }

        function fireRandomMissiles(count) {
            for(let i=0; i<count; i++) {
                const attackerIdx = Math.floor(Math.random() * warTargets.length);
                let victimIdx = Math.floor(Math.random() * warTargets.length);
                while(attackerIdx === victimIdx) {
                    victimIdx = Math.floor(Math.random() * warTargets.length);
                }
                launchMissile(warTargets[attackerIdx], warTargets[victimIdx], false);
            }
        }

        function triggerRetaliation(victimLoc) {
            if (!isWarActive) return;
            setTimeout(() => {
                if (!isWarActive) return;
                let enemyIdx = Math.floor(Math.random() * warTargets.length);
                while (warTargets[enemyIdx].name === victimLoc.name) {
                    enemyIdx = Math.floor(Math.random() * warTargets.length);
                }
                launchMissile(victimLoc, warTargets[enemyIdx], false);
            }, 1000 + Math.random() * 1500);
        }

        function launchMissile(startLocation, endLocation, isSuper = false) {
            const startPos = latLongToVector3(startLocation.lat, startLocation.lon, CONFIG.earthRadius);
            const endPos = latLongToVector3(endLocation.lat, endLocation.lon, CONFIG.earthRadius);
            const heightBoost = isSuper ? 4.5 : 2.0 + Math.random() * 1.5;
            const midPoint = startPos.clone().add(endPos).normalize().multiplyScalar(CONFIG.earthRadius + heightBoost);
            const curve = new THREE.QuadraticBezierCurve3(startPos, midPoint, endPos);
            const points = curve.getPoints(50);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: isSuper ? 0xff3300 : 0xffaa00, 
                transparent: true, opacity: isSuper ? 0.9 : 0.4, linewidth: isSuper ? 6 : 2
            });
            const trajectory = new THREE.Line(geometry, material);
            earthGroup.add(trajectory);
            const size = isSuper ? 0.15 : 0.04;
            const missileGeo = new THREE.SphereGeometry(size, 8, 8);
            const missileMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const missile = new THREE.Mesh(missileGeo, missileMat);
            if(isSuper) {
                const glowMat = new THREE.MeshBasicMaterial({color: 0xff0000, transparent:true, opacity:0.6});
                const glow = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), glowMat);
                missile.add(glow);
            }
            earthGroup.add(missile);
            activeMissiles.push({
                mesh: missile, trail: trajectory, curve: curve, progress: 0,
                speed: isSuper ? 0.002 : 0.003 + Math.random() * 0.002, 
                targetPos: endPos, isSuper: isSuper, victimLocation: endLocation
            });
        }

        function createExplosion(position, isSuper = false, victimLocation) {
            const multiplier = isSuper ? 8 : 1; 
            playExplosionSound(isSuper);
            const ringGeo = new THREE.RingGeometry(0.05 * multiplier, 0.1 * multiplier, 32);
            const ringMat = new THREE.MeshBasicMaterial({ 
                color: isSuper ? 0xff2200 : 0xffaa00, transparent: true, opacity: 0.8, side: THREE.DoubleSide 
            });
            const shockwave = new THREE.Mesh(ringGeo, ringMat);
            shockwave.position.copy(position);
            shockwave.lookAt(0,0,0);
            earthGroup.add(shockwave);
            activeExplosions.push({
                shockwave: shockwave, age: 0, maxAge: isSuper ? 200 : 100, multiplier: multiplier
            });
            setTimeout(() => createMushroomCloud(position, isSuper), 50);
            if (victimLocation) triggerRetaliation(victimLocation);
        }

        function createMushroomCloud(position, isSuper = false) {
            const group = new THREE.Group();
            group.position.copy(position);
            const up = position.clone().normalize();
            group.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), up);
            const material = new THREE.MeshStandardMaterial({
                color: isSuper ? 0x222222 : 0x444444,
                emissive: isSuper ? 0xdd0000 : 0xcc2200,
                emissiveIntensity: isSuper ? 1.0 : 0.5,
                roughness: 1, flatShading: true
            });
            const stemGeo = new THREE.CylinderGeometry(0.02, 0.01, 0.3, 8);
            stemGeo.translate(0, 0.15, 0);
            const stem = new THREE.Mesh(stemGeo, material);
            const capGeo = new THREE.DodecahedronGeometry(0.15, 1);
            capGeo.translate(0, 0.3, 0);
            const cap = new THREE.Mesh(capGeo, material);
            group.add(stem); group.add(cap);
            group.scale.set(0.1, 0.1, 0.1); 
            earthGroup.add(group);
            activeMushrooms.push({
                group: group, material: material, age: 0, maxAge: isSuper ? 1500 : 800, isSuper: isSuper
            });
        }

        function createEarth() {
            const geometry = new THREE.SphereGeometry(CONFIG.earthRadius, 128, 128);
            const material = new THREE.MeshStandardMaterial({
                map: textureLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg'),
                normalMap: textureLoader.load('https://threejs.org/examples/textures/planets/earth_normal_2048.jpg'),
                normalScale: new THREE.Vector2(0.8, 0.8),
                roughness: 0.6, metalness: 0.05
            });
            earthMesh = new THREE.Mesh(geometry, material);
            earthMesh.rotation.y = -Math.PI / 2;
            earthGroup.add(earthMesh);
            const cloudGeo = new THREE.SphereGeometry(CONFIG.earthRadius + 0.06, 128, 128);
            const cloudMat = new THREE.MeshStandardMaterial({
                map: textureLoader.load('https://threejs.org/examples/textures/planets/earth_clouds_1024.png'),
                transparent: true, opacity: 0.5, depthWrite: false, side: THREE.DoubleSide
            });
            cloudMesh = new THREE.Mesh(cloudGeo, cloudMat);
            cloudMesh.rotation.y = -Math.PI / 2; 
            earthGroup.add(cloudMesh);
            const atmosGeo = new THREE.SphereGeometry(CONFIG.earthRadius + 1.25, 64, 64);
            const atmosMat = new THREE.ShaderMaterial({
                uniforms: {
                    c: { type: "f", value: 0.6 }, p: { type: "f", value: 4.0 },
                    glowColor: { type: "c", value: new THREE.Color(0x2266cc) }, 
                    viewVector: { type: "v3", value: camera.position }
                },
                vertexShader: `
                    uniform vec3 viewVector; varying float intensity;
                    void main() {
                        vec3 vNormal = normalize( normalMatrix * normal );
                        vec3 vNormel = normalize( normalMatrix * viewVector );
                        intensity = pow( 0.65 - dot(vNormal, vNormel), 4.0 ); 
                        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                    } 
                `,
                fragmentShader: `
                    uniform vec3 glowColor; varying float intensity;
                    void main() { vec3 glow = glowColor * intensity; gl_FragColor = vec4( glow, 1.0 ); }
                `,
                side: THREE.BackSide, blending: THREE.AdditiveBlending, transparent: true
            });
            scene.add(new THREE.Mesh(atmosGeo, atmosMat));
        }

        function createLandmarks() {
            warTargets.forEach(data => {
                let mesh = null;
                const matStone = new THREE.MeshStandardMaterial({ color: 0xeeddaa });
                const matGrey = new THREE.MeshStandardMaterial({ color: 0xcccccc });
                if (data.type === 'needle') mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.02, 0.3, 8), matStone);
                else mesh = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.04), matGrey);
                if (mesh) {
                    const pos = latLongToVector3(data.lat, data.lon, CONFIG.earthRadius);
                    mesh.position.copy(pos);
                    mesh.lookAt(0, 0, 0); 
                    const normal = pos.clone().normalize();
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), normal);
                    mesh.quaternion.copy(quaternion);
                    mesh.rotateX(Math.PI / 2);
                    if (data.type === 'needle') {
                        mesh.rotateX(-Math.PI / 2); mesh.position.y += 0.15;
                    }
                    earthGroup.add(mesh);
                    const div = document.createElement('div');
                    div.className = 'label';
                    div.innerHTML = `<strong>${data.name}</strong>`;
                    document.getElementById('labels-container').appendChild(div);
                    markers.push({ mesh: mesh, dom: div });
                }
            });
        }

        function createAurora() {
            auroraGroup = new THREE.Group();
            const auroraGeo = new THREE.CylinderGeometry(CONFIG.earthRadius + 0.1, CONFIG.earthRadius + 0.5, 1.8, 64, 16, true);
            auroraGeo.translate(0, CONFIG.earthRadius * 0.95, 0);
            const vertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`;
            const fragmentShader = `
                uniform float time; uniform vec3 color; varying vec2 vUv;
                float noise(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453); }
                void main() {
                    float n = noise(vec2(vUv.x * 15.0 + time * 0.3, vUv.y * 2.0));
                    gl_FragColor = vec4(color, smoothstep(0.0, 0.4, vUv.y) * smoothstep(1.0, 0.4, vUv.y) * n * 0.8 + 0.1);
                }
            `;
            const matNorth = new THREE.ShaderMaterial({ uniforms: { time: { value: 0 }, color: { value: new THREE.Color(0x00ffcc) } }, vertexShader, fragmentShader, transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false });
            const matSouth = new THREE.ShaderMaterial({ uniforms: { time: { value: 0 }, color: { value: new THREE.Color(0xaa55ff) } }, vertexShader, fragmentShader, transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false });
            const north = new THREE.Mesh(auroraGeo, matNorth);
            const south = new THREE.Mesh(auroraGeo, matSouth);
            south.rotation.x = Math.PI;
            auroraGroup.add(north, south);
            earthGroup.add(auroraGroup);
        }

        function createStars() {
            const starGeo = new THREE.BufferGeometry();
            const count = 3500;
            const pos = new Float32Array(count * 3);
            for(let i=0; i<count; i++) {
                let r = 400 + Math.random() * 400;
                let theta = Math.random() * Math.PI * 2;
                let phi = Math.acos(2 * Math.random() - 1);
                pos[i*3] = r * Math.sin(phi) * Math.cos(theta);
                pos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                pos[i*3+2] = r * Math.cos(phi);
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.8, transparent: true, opacity: 0.8 });
            scene.add(new THREE.Points(starGeo, starMat));
        }

        function latLongToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon) * (Math.PI / 180); 
            const x = radius * Math.sin(phi) * Math.sin(theta);
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.cos(theta);
            return new THREE.Vector3(x, y, z);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            earthGroup.rotation.y += 0.0003;
            if (cloudMesh) cloudMesh.rotation.y = -Math.PI / 2 + time * 0.003;
            if (auroraGroup) auroraGroup.children.forEach(mesh => mesh.material.uniforms.time.value = time);

            if (ufoGroup) {
                const r = CONFIG.earthRadius + 2.5; 
                ufoGroup.position.set(Math.sin(time*0.5)*r, Math.cos(time*0.3)*2, Math.cos(time*0.5)*r);
                ufoGroup.lookAt(0,0,0);
            }

            if (issMarker) {
                issMarker.orbitAngle += 0.001; 
                const r = CONFIG.earthRadius + 1.0;
                const x = r * Math.cos(issMarker.orbitAngle) * 0.8;
                const y = r * Math.sin(issMarker.orbitAngle) * 0.5; 
                const z = r * Math.sin(issMarker.orbitAngle);
                issMarker.mesh.position.set(x, y, z);
                issMarker.mesh.lookAt(0,0,0); 
                issMarker.mesh.rotateX(Math.PI/2); 

                const worldPos = new THREE.Vector3();
                issMarker.mesh.getWorldPosition(worldPos);
                const screenPos = worldPos.clone().project(camera);
                const dist = worldPos.distanceTo(camera.position);
                const centerDist = camera.position.length();
                if (dist < centerDist) {
                    const x2 = (screenPos.x * .5 + .5) * window.innerWidth;
                    const y2 = (screenPos.y * -.5 + .5) * window.innerHeight;
                    issMarker.dom.style.left = `${x2}px`;
                    issMarker.dom.style.top = `${y2}px`;
                    issMarker.dom.classList.add('visible');
                } else {
                    issMarker.dom.classList.remove('visible');
                }
            }

            for (let i = activeMissiles.length - 1; i >= 0; i--) {
                const m = activeMissiles[i];
                m.progress += m.speed;
                if (m.progress >= 1) {
                    createExplosion(m.targetPos, m.isSuper, m.victimLocation);
                    earthGroup.remove(m.mesh);
                    earthGroup.remove(m.trail);
                    activeMissiles.splice(i, 1);
                } else {
                    const pos = m.curve.getPoint(m.progress);
                    m.mesh.position.copy(pos);
                }
            }

            for (let i = activeExplosions.length - 1; i >= 0; i--) {
                const e = activeExplosions[i];
                e.age++;
                const baseScale = 1 + (e.age / 10);
                const scale = baseScale * e.multiplier;
                e.shockwave.scale.set(scale * 1.5, scale * 1.5, 1);
                e.shockwave.material.opacity = (1 - (e.age / e.maxAge)) * 0.8;
                if (e.age >= e.maxAge) {
                    earthGroup.remove(e.shockwave);
                    activeExplosions.splice(i, 1);
                }
            }

            for (let i = activeMushrooms.length - 1; i >= 0; i--) {
                const m = activeMushrooms[i];
                m.age++;
                const growSpeed = m.isSuper ? 80 : 40; 
                const maxScale = m.isSuper ? 15.0 : 2.5; 
                if (m.age < growSpeed) {
                    const growth = Math.min(m.age / growSpeed, 1) * maxScale; 
                    m.group.scale.set(growth, growth, growth);
                }
                if (m.age > growSpeed) {
                    m.material.emissiveIntensity = Math.max(0, (m.isSuper ? 1.0 : 0.5) - (m.age - growSpeed) * 0.005);
                }
                if (m.age >= m.maxAge) {
                    m.group.scale.multiplyScalar(0.99); 
                    if (m.group.scale.x < 0.1) {
                        earthGroup.remove(m.group);
                        activeMushrooms.splice(i, 1);
                    }
                }
            }

            markers.forEach(marker => {
                const worldPos = new THREE.Vector3();
                marker.mesh.getWorldPosition(worldPos);
                const dist = worldPos.distanceTo(camera.position);
                if (dist < camera.position.length() + 0.5) {
                    const screenPos = worldPos.clone().project(camera);
                    const x = (screenPos.x * .5 + .5) * window.innerWidth;
                    const y = (screenPos.y * -.5 + .5) * window.innerHeight;
                    if(x>0 && x<window.innerWidth && y>0 && y<window.innerHeight) {
                        marker.dom.style.left = `${x}px`;
                        marker.dom.style.top = `${y}px`;
                        marker.dom.classList.add('visible');
                    } else marker.dom.classList.remove('visible');
                } else marker.dom.classList.remove('visible');
            });

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>


